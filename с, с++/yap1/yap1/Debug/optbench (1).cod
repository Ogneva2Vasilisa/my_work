; Listing generated by Microsoft (R) Optimizing Compiler Version 19.25.28610.4 

	TITLE	C:\Users\vas\Downloads\optbench (1).c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_i:DWORD
COMM	_j:DWORD
COMM	_k:DWORD
COMM	_l:DWORD
COMM	_m:DWORD
COMM	_i2:DWORD
COMM	_j2:DWORD
COMM	_k2:DWORD
COMM	_g3:DWORD
COMM	_h3:DWORD
COMM	_i3:DWORD
COMM	_k3:DWORD
COMM	_m3:DWORD
COMM	_i4:DWORD
COMM	_j4:DWORD
COMM	_i5:DWORD
COMM	_j5:DWORD
COMM	_k5:DWORD
COMM	_flt_1:QWORD
COMM	_flt_2:QWORD
COMM	_flt_3:QWORD
COMM	_flt_4:QWORD
COMM	_flt_5:QWORD
COMM	_flt_6:QWORD
COMM	_ivector:DWORD:03H
COMM	_ivector2:BYTE:03H
COMM	_ivector4:WORD:06H
COMM	_ivector5:DWORD:064H
_DATA	ENDS
msvcjmc	SEGMENT
__A2143F22_corecrt_stdio_config@h DB 01H
__829E1958_corecrt_wstdio@h DB 01H
__6DFAE8B8_stdio@h DB 01H
__1FEB9909_corecrt_memcpy_s@h DB 01H
__9200769A_corecrt_wstring@h DB 01H
__32E5F013_string@h DB 01H
__F85A029D_optbench (1)@c DB 01H
msvcjmc	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_printf
PUBLIC	_dead_code
PUBLIC	_unnecessary_loop
PUBLIC	_loop_jamming
PUBLIC	_loop_unrolling
PUBLIC	_jump_compression
PUBLIC	_main
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0EG@FMOENJDP@This?5compiler?5handles?5divide?9by@ ; `string'
PUBLIC	??_C@_0CC@DDFJGIGO@Common?5subexpression?5eliminatio@ ; `string'
PUBLIC	??_C@_0CA@EAKPGJJD@This?5line?5should?5not?5be?5printed@ ; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6@			; `string'
PUBLIC	__real@0000000000000000
PUBLIC	__real@3ff000001ad7f29b
PUBLIC	__real@4003333333333333
PUBLIC	__real@4021666666666666
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT __real@4021666666666666
CONST	SEGMENT
__real@4021666666666666 DQ 04021666666666666r	; 8.7
CONST	ENDS
;	COMDAT __real@4003333333333333
CONST	SEGMENT
__real@4003333333333333 DQ 04003333333333333r	; 2.4
CONST	ENDS
;	COMDAT __real@3ff000001ad7f29b
CONST	SEGMENT
__real@3ff000001ad7f29b DQ 03ff000001ad7f29br	; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@EAKPGJJD@This?5line?5should?5not?5be?5printed@
CONST	SEGMENT
??_C@_0CA@EAKPGJJD@This?5line?5should?5not?5be?5printed@ DB 'This line sh'
	DB	'ould not be printed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@DDFJGIGO@Common?5subexpression?5eliminatio@
CONST	SEGMENT
??_C@_0CC@DDFJGIGO@Common?5subexpression?5eliminatio@ DB 'Common subexpre'
	DB	'ssion elimination', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@FMOENJDP@This?5compiler?5handles?5divide?9by@
CONST	SEGMENT
??_C@_0EG@FMOENJDP@This?5compiler?5handles?5divide?9by@ DB 'This compiler'
	DB	' handles divide-by-zero as                     an error', 0aH
	DB	00H						; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\vas\Downloads\optbench (1).c
;	COMDAT _main
_TEXT	SEGMENT
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC						; COMDAT

; 53   :          {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F85A029D_optbench (1)@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 54   : 	       /* ���������������������������� *
; 55   :             � ����������� ����⠭� � ����� �
; 56   :             *������������������������������*/
; 57   : 
; 58   :             j4 = 2;

  00028	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR _j4, 2

; 59   :             if( i2 < j4 && i4 < j4 )

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR _i2
  00037	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _j4
  0003d	7d 17		 jge	 SHORT $LN14@main
  0003f	a1 00 00 00 00	 mov	 eax, DWORD PTR _i4
  00044	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _j4
  0004a	7d 0a		 jge	 SHORT $LN14@main

; 60   :                 i2 = 2;

  0004c	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR _i2, 2
$LN14@main:

; 61   : 
; 62   :             j4 = k5;

  00056	a1 00 00 00 00	 mov	 eax, DWORD PTR _k5
  0005b	a3 00 00 00 00	 mov	 DWORD PTR _j4, eax

; 63   :             if( i2 < j4 && i4 < j4 )

  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR _i2
  00065	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _j4
  0006b	7d 17		 jge	 SHORT $LN15@main
  0006d	a1 00 00 00 00	 mov	 eax, DWORD PTR _i4
  00072	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _j4
  00078	7d 0a		 jge	 SHORT $LN15@main

; 64   :                 i5 = 3;

  0007a	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR _i5, 3
$LN15@main:

; 65   : 
; 66   :            /* ������������������������������������������ *
; 67   : 	    � ����⪠ ����⠭�, ��䬥��᪨� ⮦���⢠ �
; 68   :             � � ����譨� ����樨 ����㧪�/��࠭����    �
; 69   :             * ������������������������������������������ */
; 70   : 
; 71   :             i3 = 1 + 2;

  00084	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR _i3, 3

; 72   :             flt_1 = 2.4 + 6.3;

  0008e	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4021666666666666
  00096	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _flt_1, xmm0

; 73   :             i2 = 5;

  0009e	c7 05 00 00 00
	00 05 00 00 00	 mov	 DWORD PTR _i2, 5

; 74   :             j2 = i + 0;

  000a8	a1 00 00 00 00	 mov	 eax, DWORD PTR _i
  000ad	a3 00 00 00 00	 mov	 DWORD PTR _j2, eax

; 75   :             k2 = i / 1;

  000b2	a1 00 00 00 00	 mov	 eax, DWORD PTR _i
  000b7	a3 00 00 00 00	 mov	 DWORD PTR _k2, eax

; 76   :             i4 = i * 1;

  000bc	a1 00 00 00 00	 mov	 eax, DWORD PTR _i
  000c1	a3 00 00 00 00	 mov	 DWORD PTR _i4, eax

; 77   :             i5 = i * 0;

  000c6	6b 05 00 00 00
	00 00		 imul	 eax, DWORD PTR _i, 0
  000cd	a3 00 00 00 00	 mov	 DWORD PTR _i5, eax

; 78   : 
; 79   :        //#ifndef NO_ZERO_DIVIDE
; 80   : 	    /*
; 81   :              *   ������� ���������� �ᯮ����� �訡��
; 82   :              *   ������� �� ��� � �� ��������� ��ꥪ�� ���
; 83   :              */
; 84   :             //i2 = i / 0;
; 85   :             //flt_2 = flt_1 / 0.0;
; 86   :        //#else
; 87   :             printf( "This compiler handles divide-by-zero as \

  000d2	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@FMOENJDP@This?5compiler?5handles?5divide?9by@
  000d7	e8 00 00 00 00	 call	 _printf
  000dc	83 c4 04	 add	 esp, 4

; 88   :                     an error\n");
; 89   :        //#endif
; 90   :             flt_3 = 2.4 / 1.0;

  000df	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4003333333333333
  000e7	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _flt_3, xmm0

; 91   :             flt_4 = 1.0 + 0.0000001;

  000ef	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff000001ad7f29b
  000f7	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _flt_4, xmm0

; 92   :             flt_5 = flt_6 * 0.0;

  000ff	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR _flt_6
  00107	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@0000000000000000
  0010f	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _flt_5, xmm0

; 93   : 	    flt_6 = flt_2 * flt_3;

  00117	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR _flt_2
  0011f	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR _flt_3
  00127	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR _flt_6, xmm0

; 94   : 
; 95   :             /* �������������������� *
; 96   :              �  ��譥� ��ᢠ������ �
; 97   :              * �������������������� */
; 98   : 
; 99   :             k3 = 1;

  0012f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _k3, 1

; 100  :             k3 = 1;

  00139	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _k3, 1

; 101  : 
; 102  :             /* ������������������ *
; 103  :              �  �������� ��魮�� �
; 104  :              * ������������������ */
; 105  : 
; 106  : 	    k2 = 4 * j5;

  00143	a1 00 00 00 00	 mov	 eax, DWORD PTR _j5
  00148	c1 e0 02	 shl	 eax, 2
  0014b	a3 00 00 00 00	 mov	 DWORD PTR _k2, eax

; 107  : 	    for( i = 0; i <= 5; i++ )

  00150	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _i, 0
  0015a	eb 0d		 jmp	 SHORT $LN4@main
$LN2@main:
  0015c	a1 00 00 00 00	 mov	 eax, DWORD PTR _i
  00161	83 c0 01	 add	 eax, 1
  00164	a3 00 00 00 00	 mov	 DWORD PTR _i, eax
$LN4@main:
  00169	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR _i, 5
  00170	7f 17		 jg	 SHORT $LN3@main

; 108  : 		ivector4[ i ] = i * 2;

  00172	a1 00 00 00 00	 mov	 eax, DWORD PTR _i
  00177	d1 e0		 shl	 eax, 1
  00179	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _i
  0017f	66 89 04 4d 00
	00 00 00	 mov	 WORD PTR _ivector4[ecx*2], ax
  00187	eb d3		 jmp	 SHORT $LN2@main
$LN3@main:

; 109  : 
; 110  : 	    /* ������������� *
; 111  :              �  ���⮩ 横� �
; 112  :              * ������������� */
; 113  : 
; 114  :             j5 = 0;

  00189	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _j5, 0

; 115  :             k5 = 10000;

  00193	c7 05 00 00 00
	00 10 27 00 00	 mov	 DWORD PTR _k5, 10000	; 00002710H
$LN7@main:

; 116  :             do {
; 117  :                 k5 = k5 - 1;

  0019d	a1 00 00 00 00	 mov	 eax, DWORD PTR _k5
  001a2	83 e8 01	 sub	 eax, 1
  001a5	a3 00 00 00 00	 mov	 DWORD PTR _k5, eax

; 118  :                 j5 = j5 + 1;

  001aa	a1 00 00 00 00	 mov	 eax, DWORD PTR _j5
  001af	83 c0 01	 add	 eax, 1
  001b2	a3 00 00 00 00	 mov	 DWORD PTR _j5, eax

; 119  :                 i5 = (k5 * 3) / (j5 * constant5);

  001b7	6b 05 00 00 00
	00 03		 imul	 eax, DWORD PTR _k5, 3
  001be	6b 0d 00 00 00
	00 05		 imul	 ecx, DWORD PTR _j5, 5
  001c5	99		 cdq
  001c6	f7 f9		 idiv	 ecx
  001c8	a3 00 00 00 00	 mov	 DWORD PTR _i5, eax

; 120  :                } while ( k5 > 0 );

  001cd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _k5, 0
  001d4	7f c7		 jg	 SHORT $LN7@main

; 121  : 
; 122  :             /* �������������������������������������� *
; 123  : 	     �  ��ࠢ����� ��६����� ����樨 横��  �
; 124  :              * �������������������������������������� */
; 125  :             for( i = 0; i < 100; i++ )

  001d6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _i, 0
  001e0	eb 0d		 jmp	 SHORT $LN10@main
$LN8@main:
  001e2	a1 00 00 00 00	 mov	 eax, DWORD PTR _i
  001e7	83 c0 01	 add	 eax, 1
  001ea	a3 00 00 00 00	 mov	 DWORD PTR _i, eax
$LN10@main:
  001ef	83 3d 00 00 00
	00 64		 cmp	 DWORD PTR _i, 100	; 00000064H
  001f6	7d 14		 jge	 SHORT $LN9@main

; 126  :                 ivector5[ i * 2 + 3 ] = 5;

  001f8	a1 00 00 00 00	 mov	 eax, DWORD PTR _i
  001fd	d1 e0		 shl	 eax, 1
  001ff	c7 04 85 0c 00
	00 00 05 00 00
	00		 mov	 DWORD PTR _ivector5[eax*4+12], 5
  0020a	eb d6		 jmp	 SHORT $LN8@main
$LN9@main:

; 127  : 
; 128  :             /* ����������������������� *
; 129  :              �  ��㡮��� �����ࠦ����  �
; 130  :              * ����������������������� */
; 131  : 
; 132  :             if( i < 10 )

  0020c	83 3d 00 00 00
	00 0a		 cmp	 DWORD PTR _i, 10	; 0000000aH
  00213	7d 12		 jge	 SHORT $LN16@main

; 133  :                 j5 = i5 + i2;

  00215	a1 00 00 00 00	 mov	 eax, DWORD PTR _i5
  0021a	03 05 00 00 00
	00		 add	 eax, DWORD PTR _i2
  00220	a3 00 00 00 00	 mov	 DWORD PTR _j5, eax
  00225	eb 10		 jmp	 SHORT $LN17@main
$LN16@main:

; 134  :             else
; 135  :                 k5 = i5 + i2;

  00227	a1 00 00 00 00	 mov	 eax, DWORD PTR _i5
  0022c	03 05 00 00 00
	00		 add	 eax, DWORD PTR _i2
  00232	a3 00 00 00 00	 mov	 DWORD PTR _k5, eax
$LN17@main:

; 136  : 
; 137  :             /* ������������������������������������������������ *
; 138  :              �  �஢�ઠ ⮣�, ��� ��������� �������� ����  �
; 139  :              �  ��६����� � ����⠭�� �����ᮬ, ࠧ�������   �
; 140  :              �  ����� � ॣ�����                                �
; 141  :              * ������������������������������������������������ */
; 142  : 
; 143  :             ivector[ 0 ] = 1;  /* ������� ����⠭⭮�� ���� */

  00237	b8 04 00 00 00	 mov	 eax, 4
  0023c	6b c8 00	 imul	 ecx, eax, 0
  0023f	c7 81 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _ivector[ecx], 1

; 144  :             ivector[ i2 ] = 2; /* ���祭�� i2 ������ ���� ᪮��஢���*/

  00249	a1 00 00 00 00	 mov	 eax, DWORD PTR _i2
  0024e	c7 04 85 00 00
	00 00 02 00 00
	00		 mov	 DWORD PTR _ivector[eax*4], 2

; 145  :             ivector[ i2 ] = 2; /* ����஢���� ॣ���஢ */

  00259	a1 00 00 00 00	 mov	 eax, DWORD PTR _i2
  0025e	c7 04 85 00 00
	00 00 02 00 00
	00		 mov	 DWORD PTR _ivector[eax*4], 2

; 146  :             ivector[ 2 ] = 3;  /* ������� ����⠭⭮�� ���� */

  00269	b8 04 00 00 00	 mov	 eax, 4
  0026e	d1 e0		 shl	 eax, 1
  00270	c7 80 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR _ivector[eax], 3

; 147  : 
; 148  : 
; 149  : 	    /* ����������������������������� *
; 150  :              �  �������� ���� �����ࠦ����  �
; 151  :              * ����������������������������� */
; 152  : 
; 153  :             if(( h3 + k3 ) < 0 || ( h3 + k3 ) > 5 )

  0027a	a1 00 00 00 00	 mov	 eax, DWORD PTR _h3
  0027f	03 05 00 00 00
	00		 add	 eax, DWORD PTR _k3
  00285	78 10		 js	 SHORT $LN20@main
  00287	a1 00 00 00 00	 mov	 eax, DWORD PTR _h3
  0028c	03 05 00 00 00
	00		 add	 eax, DWORD PTR _k3
  00292	83 f8 05	 cmp	 eax, 5
  00295	7e 0f		 jle	 SHORT $LN18@main
$LN20@main:

; 154  :                 printf("Common subexpression elimination\n");

  00297	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@DDFJGIGO@Common?5subexpression?5eliminatio@
  0029c	e8 00 00 00 00	 call	 _printf
  002a1	83 c4 04	 add	 esp, 4
  002a4	eb 2d		 jmp	 SHORT $LN19@main
$LN18@main:

; 155  :             else {
; 156  :                 m3 = ( h3 + k3 ) / i3;

  002a6	a1 00 00 00 00	 mov	 eax, DWORD PTR _h3
  002ab	03 05 00 00 00
	00		 add	 eax, DWORD PTR _k3
  002b1	99		 cdq
  002b2	f7 3d 00 00 00
	00		 idiv	 DWORD PTR _i3
  002b8	a3 00 00 00 00	 mov	 DWORD PTR _m3, eax

; 157  : 		g3 = i3 + (h3 + k3);

  002bd	a1 00 00 00 00	 mov	 eax, DWORD PTR _h3
  002c2	03 05 00 00 00
	00		 add	 eax, DWORD PTR _k3
  002c8	03 05 00 00 00
	00		 add	 eax, DWORD PTR _i3
  002ce	a3 00 00 00 00	 mov	 DWORD PTR _g3, eax
$LN19@main:

; 158  :             }
; 159  : 
; 160  :             /* �������������������������������������� *
; 161  :              �  �뭥ᥭ�� ����ਠ�⭮�� ����          �
; 162  :              �  (j * k) ����� ���� �뭥ᥭ� �� 横��  �
; 163  : 	     * �������������������������������������� */
; 164  : 
; 165  :             for( i4 = 0; i4 <= max_vector; i4++)

  002d3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _i4, 0
  002dd	eb 0d		 jmp	 SHORT $LN13@main
$LN11@main:
  002df	a1 00 00 00 00	 mov	 eax, DWORD PTR _i4
  002e4	83 c0 01	 add	 eax, 1
  002e7	a3 00 00 00 00	 mov	 DWORD PTR _i4, eax
$LN13@main:
  002ec	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _i4, 2
  002f3	7f 1a		 jg	 SHORT $LN12@main

; 166  :                 ivector2[ i4 ] = j * k;

  002f5	a1 00 00 00 00	 mov	 eax, DWORD PTR _j
  002fa	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _k
  00301	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _i4
  00307	88 81 00 00 00
	00		 mov	 BYTE PTR _ivector2[ecx], al
  0030d	eb d0		 jmp	 SHORT $LN11@main
$LN12@main:

; 167  : 
; 168  : 	    /* ����������������������������� *
; 169  : 	     �  �맮� �㭪樨 � ��㬥�⠬�  �
; 170  : 	     * ����������������������������� */
; 171  : 
; 172  : 	    dead_code( 1, "This line should not be printed" );

  0030f	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@EAKPGJJD@This?5line?5should?5not?5be?5printed@
  00314	6a 01		 push	 1
  00316	e8 00 00 00 00	 call	 _dead_code
  0031b	83 c4 08	 add	 esp, 8

; 173  : 
; 174  : 	    /* ������������������������������ *
; 175  :              �  �맮� �㭪樨 ��� ��㬥�⮢  �
; 176  :              * ������������������������������ */
; 177  : 
; 178  :             unnecessary_loop();

  0031e	e8 00 00 00 00	 call	 _unnecessary_loop

; 179  : 
; 180  : 	//------------------------------------------------------
; 181  : 	loop_jamming(7);

  00323	6a 07		 push	 7
  00325	e8 00 00 00 00	 call	 _loop_jamming
  0032a	83 c4 04	 add	 esp, 4

; 182  : 	loop_unrolling(7);

  0032d	6a 07		 push	 7
  0032f	e8 00 00 00 00	 call	 _loop_unrolling
  00334	83 c4 04	 add	 esp, 4

; 183  : 	jump_compression(1, 2, 3, 4, 5);

  00337	6a 05		 push	 5
  00339	6a 04		 push	 4
  0033b	6a 03		 push	 3
  0033d	6a 02		 push	 2
  0033f	6a 01		 push	 1
  00341	e8 00 00 00 00	 call	 _jump_compression
  00346	83 c4 14	 add	 esp, 20			; 00000014H

; 184  : 
; 185  :          }    /* ����� �㭪樨 main */

  00349	33 c0		 xor	 eax, eax
  0034b	5f		 pop	 edi
  0034c	5e		 pop	 esi
  0034d	5b		 pop	 ebx
  0034e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00354	3b ec		 cmp	 ebp, esp
  00356	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0035b	8b e5		 mov	 esp, ebp
  0035d	5d		 pop	 ebp
  0035e	c3		 ret	 0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\vas\Downloads\optbench (1).c
;	COMDAT _jump_compression
_TEXT	SEGMENT
_i$ = 8							; size = 4
_j$ = 12						; size = 4
_k$ = 16						; size = 4
_l$ = 20						; size = 4
_m$ = 24						; size = 4
_jump_compression PROC					; COMDAT

; 264  :            {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F85A029D_optbench (1)@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
$beg_1$11:

; 265  :        beg_1:
; 266  :                if( i < j )

  00028	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  0002b	3b 45 0c	 cmp	 eax, DWORD PTR _j$[ebp]
  0002e	7d 3f		 jge	 SHORT $LN2@jump_compr

; 267  :                    if( j < k )

  00030	8b 45 0c	 mov	 eax, DWORD PTR _j$[ebp]
  00033	3b 45 10	 cmp	 eax, DWORD PTR _k$[ebp]
  00036	7d 2a		 jge	 SHORT $LN4@jump_compr

; 268  :                        if( k < l )

  00038	8b 45 10	 mov	 eax, DWORD PTR _k$[ebp]
  0003b	3b 45 14	 cmp	 eax, DWORD PTR _l$[ebp]
  0003e	7d 17		 jge	 SHORT $LN6@jump_compr

; 269  : 			   if( l < m )

  00040	8b 45 14	 mov	 eax, DWORD PTR _l$[ebp]
  00043	3b 45 18	 cmp	 eax, DWORD PTR _m$[ebp]
  00046	7d 0b		 jge	 SHORT $LN8@jump_compr

; 270  :                                l += m;

  00048	8b 45 14	 mov	 eax, DWORD PTR _l$[ebp]
  0004b	03 45 18	 add	 eax, DWORD PTR _m$[ebp]
  0004e	89 45 14	 mov	 DWORD PTR _l$[ebp], eax
  00051	eb 02		 jmp	 SHORT $LN9@jump_compr
$LN8@jump_compr:

; 271  :                            else
; 272  :                                goto end_1;

  00053	eb 16		 jmp	 SHORT $end_1$12
$LN9@jump_compr:
  00055	eb 09		 jmp	 SHORT $LN7@jump_compr
$LN6@jump_compr:

; 273  :                        else
; 274  :                            k += l;

  00057	8b 45 10	 mov	 eax, DWORD PTR _k$[ebp]
  0005a	03 45 14	 add	 eax, DWORD PTR _l$[ebp]
  0005d	89 45 10	 mov	 DWORD PTR _k$[ebp], eax
$LN7@jump_compr:
  00060	eb 0b		 jmp	 SHORT $LN5@jump_compr
$LN4@jump_compr:

; 275  :                    else {
; 276  :                        j += k;

  00062	8b 45 0c	 mov	 eax, DWORD PTR _j$[ebp]
  00065	03 45 10	 add	 eax, DWORD PTR _k$[ebp]
  00068	89 45 0c	 mov	 DWORD PTR _j$[ebp], eax
$end_1$12:

; 277  : end_1:
; 278  :                        goto beg_1;

  0006b	eb bb		 jmp	 SHORT $beg_1$11
$LN5@jump_compr:

; 279  :                    }

  0006d	eb 09		 jmp	 SHORT $LN3@jump_compr
$LN2@jump_compr:

; 280  :                else
; 281  :                    i += j;

  0006f	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00072	03 45 0c	 add	 eax, DWORD PTR _j$[ebp]
  00075	89 45 08	 mov	 DWORD PTR _i$[ebp], eax
$LN3@jump_compr:

; 282  :                return( i + j + k + l + m );

  00078	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  0007b	03 45 0c	 add	 eax, DWORD PTR _j$[ebp]
  0007e	03 45 10	 add	 eax, DWORD PTR _k$[ebp]
  00081	03 45 14	 add	 eax, DWORD PTR _l$[ebp]
  00084	03 45 18	 add	 eax, DWORD PTR _m$[ebp]

; 283  :            } /* ����� jump_compression */

  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx
  0008a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00090	3b ec		 cmp	 ebp, esp
  00092	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
_jump_compression ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\vas\Downloads\optbench (1).c
;	COMDAT _loop_unrolling
_TEXT	SEGMENT
$T1 = -200						; size = 4
_x$ = 8							; size = 4
_loop_unrolling PROC					; COMDAT

; 250  :             {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F85A029D_optbench (1)@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 251  :                 for( i = 0; i < 6; i++ )

  00028	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _i, 0
  00032	eb 0d		 jmp	 SHORT $LN4@loop_unrol
$LN2@loop_unrol:
  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR _i
  00039	83 c0 01	 add	 eax, 1
  0003c	a3 00 00 00 00	 mov	 DWORD PTR _i, eax
$LN4@loop_unrol:
  00041	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _i, 6
  00048	7d 2e		 jge	 SHORT $LN5@loop_unrol

; 252  :                     ivector4[ i ] = 0;

  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR _i
  0004f	d1 e0		 shl	 eax, 1
  00051	89 85 38 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00057	83 bd 38 ff ff
	ff 0c		 cmp	 DWORD PTR $T1[ebp], 12	; 0000000cH
  0005e	73 02		 jae	 SHORT $LN6@loop_unrol
  00060	eb 05		 jmp	 SHORT $LN7@loop_unrol
$LN6@loop_unrol:
  00062	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN7@loop_unrol:
  00067	33 c9		 xor	 ecx, ecx
  00069	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  0006f	66 89 8a 00 00
	00 00		 mov	 WORD PTR _ivector4[edx], cx
  00076	eb bc		 jmp	 SHORT $LN2@loop_unrol
$LN5@loop_unrol:

; 253  : 	    } /* ����� loop_unrolling */

  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00081	3b ec		 cmp	 ebp, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
_loop_unrolling ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\vas\Downloads\optbench (1).c
;	COMDAT _loop_jamming
_TEXT	SEGMENT
_x$ = 8							; size = 4
_loop_jamming PROC					; COMDAT

; 232  :             {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F85A029D_optbench (1)@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 233  :                 for( i = 0; i < 5; i++ )

  00028	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _i, 0
  00032	eb 0d		 jmp	 SHORT $LN4@loop_jammi
$LN2@loop_jammi:
  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR _i
  00039	83 c0 01	 add	 eax, 1
  0003c	a3 00 00 00 00	 mov	 DWORD PTR _i, eax
$LN4@loop_jammi:
  00041	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR _i, 5
  00048	7d 16		 jge	 SHORT $LN3@loop_jammi

; 234  :                     k5 = x + j5 * i;

  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR _j5
  0004f	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _i
  00056	03 45 08	 add	 eax, DWORD PTR _x$[ebp]
  00059	a3 00 00 00 00	 mov	 DWORD PTR _k5, eax
  0005e	eb d4		 jmp	 SHORT $LN2@loop_jammi
$LN3@loop_jammi:

; 235  :                 for( i = 0; i < 5; i++ )

  00060	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _i, 0
  0006a	eb 0d		 jmp	 SHORT $LN7@loop_jammi
$LN5@loop_jammi:
  0006c	a1 00 00 00 00	 mov	 eax, DWORD PTR _i
  00071	83 c0 01	 add	 eax, 1
  00074	a3 00 00 00 00	 mov	 DWORD PTR _i, eax
$LN7@loop_jammi:
  00079	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR _i, 5
  00080	7d 18		 jge	 SHORT $LN1@loop_jammi

; 236  :                     i5 = x * k5 * i;

  00082	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00085	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _k5
  0008c	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _i
  00093	a3 00 00 00 00	 mov	 DWORD PTR _i5, eax
  00098	eb d2		 jmp	 SHORT $LN5@loop_jammi
$LN1@loop_jammi:

; 237  :             } /* ����� loop_jamming */

  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx
  0009d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000a3	3b ec		 cmp	 ebp, esp
  000a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
_loop_jamming ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\vas\Downloads\optbench (1).c
;	COMDAT _unnecessary_loop
_TEXT	SEGMENT
_x$ = -8						; size = 4
_unnecessary_loop PROC					; COMDAT

; 214  :             {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F85A029D_optbench (1)@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 215  :               int x;
; 216  : 
; 217  :               x = 0;

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0

; 218  :               for( i = 0; i < 5; i++ )  /* ���� �� ������

  0002f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _i, 0
  00039	eb 0d		 jmp	 SHORT $LN4@unnecessar
$LN2@unnecessar:
  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _i
  00040	83 c0 01	 add	 eax, 1
  00043	a3 00 00 00 00	 mov	 DWORD PTR _i, eax
$LN4@unnecessar:
  00048	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR _i, 5
  0004f	7d 10		 jge	 SHORT $LN1@unnecessar

; 219  :                                              �����஢�����*/
; 220  :                   k5 = x + j5;

  00051	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  00054	03 05 00 00 00
	00		 add	 eax, DWORD PTR _j5
  0005a	a3 00 00 00 00	 mov	 DWORD PTR _k5, eax
  0005f	eb da		 jmp	 SHORT $LN2@unnecessar
$LN1@unnecessar:

; 221  :             } /* ����� unnecessary_loop */

  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
  00064	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006a	3b ec		 cmp	 ebp, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
_unnecessary_loop ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\vas\Downloads\optbench (1).c
;	COMDAT _dead_code
_TEXT	SEGMENT
_idead_store$ = -8					; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_dead_code PROC						; COMDAT

; 197  :             {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F85A029D_optbench (1)@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 198  :               int idead_store;
; 199  : 
; 200  :               idead_store = a;

  00028	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0002b	89 45 f8	 mov	 DWORD PTR _idead_store$[ebp], eax

; 201  :               if( 0 )

  0002e	33 c0		 xor	 eax, eax
  00030	74 11		 je	 SHORT $LN1@dead_code

; 202  :                   printf( "%s\n", b );

  00032	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  00035	50		 push	 eax
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
  0003b	e8 00 00 00 00	 call	 _printf
  00040	83 c4 08	 add	 esp, 8
$LN1@dead_code:

; 203  :             } /* ����� dead_code */

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004c	3b ec		 cmp	 ebp, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
_dead_code ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 956  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __6DFAE8B8_stdio@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

  00028	8d 45 0c	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0002b	89 45 ec	 mov	 DWORD PTR __ArgList$[ebp], eax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  0002e	8b 45 ec	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00031	50		 push	 eax
  00032	6a 00		 push	 0
  00034	8b 4d 08	 mov	 ecx, DWORD PTR __Format$[ebp]
  00037	51		 push	 ecx
  00038	8b f4		 mov	 esi, esp
  0003a	6a 01		 push	 1
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00042	83 c4 04	 add	 esp, 4
  00045	3b f4		 cmp	 esi, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 __vfprintf_l
  00052	83 c4 10	 add	 esp, 16			; 00000010H
  00055	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 961  :         __crt_va_end(_ArgList);

  00058	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 962  :         return _Result;

  0005f	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 963  :     }

  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 644  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __6DFAE8B8_stdio@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00028	8b f4		 mov	 esi, esp
  0002a	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00035	52		 push	 edx
  00036	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0003f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00042	51		 push	 ecx
  00043	8b 10		 mov	 edx, DWORD PTR [eax]
  00045	52		 push	 edx
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  0004c	83 c4 18	 add	 esp, 24			; 00000018H
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 646  :     }

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __A2143F22_corecrt_stdio_config@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00028	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
